import { WASocket, proto, downloadMediaMessage } from '@whiskeysockets/baileys';
import { ICommand } from '@/interfaces/ICommand';
import { canUseCommand } from '@/utils/permissions';
import { getUserDisplayName } from '@/utils/userUtils';
import { GameService } from '@/services/GameService';
import { inject, injectable } from 'inversify';
import * as fs from 'fs';
import * as path from 'path';
import { Group } from '@/database/models/GroupSchema';
import { TYPES } from '@/config/container';
import { ConfessionGame } from '../brincadeiras/confissao';

type WAMessage = proto.IWebMessageInfo;

// Sistema de gerenciamento de estado tempor√°rio para escolha de grupo
const pendingGroupChoices = new Map<string, { 
  options: Array<{ groupId: string; groupName: string; isCreatorGroup: boolean }>;
  photoData: { messageId: string; photoUrl: string; caption?: string };
  timestamp: number;
  step: 'confirm' | 'choose';
}>();

// Pasta para salvar fotos do jogo
const GAME_FOLDER = path.join(process.cwd(), 'jogos', 'ppp');

// Sistema de gerenciamento de estado tempor√°rio para escolha de grupo de confiss√£o
const pendingConfessionChoices = new Map<string, { 
  options: Array<{ groupId: string; groupName: string; isCreatorGroup: boolean }>;
  confessionData: { messageId: string; confession: string };
  timestamp: number;
  step: 'confirm' | 'choose';
}>();

// Fun√ß√£o para baixar e salvar foto do jogo
async function downloadGamePhoto(sock: WASocket, message: WAMessage, userJid: string): Promise<string> {
  try {
    const messageContent = message.message;
    if (!messageContent?.imageMessage) {
      throw new Error('Mensagem n√£o cont√©m imagem');
    }

    // Criar pasta se n√£o existir
    if (!fs.existsSync(GAME_FOLDER)) {
      fs.mkdirSync(GAME_FOLDER, { recursive: true });
    }

    const mediaBuffer = await downloadMediaMessage(message, 'buffer', {});
    const timestamp = Date.now();
    const userNumber = userJid.split('@')[0];
    const fileName = `ppp_${timestamp}_${userNumber}.jpg`;
    const filePath = path.join(GAME_FOLDER, fileName);
    
    fs.writeFileSync(filePath, mediaBuffer);
    
    return filePath;
  } catch (error) {
    console.error('[ERROR] Erro ao baixar foto do jogo:', error);
    throw error;
  }
}

@injectable()
export class BrincadeiraCommand implements ICommand {
  constructor(
    @inject(TYPES.GameService) private gameService: GameService
  ) {}

  name = 'brincadeira';
  aliases = ['jogo', 'game'];
  description = 'Gerencia o jogo Pego, Penso ou Passo (PPP) e Confiss√£o (Confession√°rio An√¥nimo)';
  category: 'admin' = 'admin';
  usage = '!brincadeira ppp ativar - Ativa o jogo\n!brincadeira ppp enviar - Envia as fotos\n!brincadeira ppp status - Status do jogo\n!brincadeira confissao ativar - Ativa o jogo de Confiss√£o\n!brincadeira confissao revelar - Revela as confiss√µes\n!brincadeira confissao status - Status do jogo de Confiss√£o\n!brincadeira confissao cancelar - Cancela o jogo de Confiss√£o\n!brincadeira confissao encerrar - Finaliza o jogo de Confiss√£o\n!brincadeira confissao ranking - Ver ranking dos mais chocantes\n!brincadeira confissao chocantes - Ver confiss√µes chocantes\n!brincadeira confissao micos - Ver confiss√µes engra√ßadas\n!brincadeira confissao resultado - Resultado completo do jogo de Confiss√£o';

  async execute(sock: WASocket, message: WAMessage, args: string[]): Promise<void> {
    try {
      const groupJid = message.key.remoteJid!;
      if (!groupJid.endsWith('@g.us')) {
        await sock.sendMessage(groupJid, { 
          text: 'Eita, baby! ü´£ O jogo s√≥ funciona em grupos! üíã' 
        });
        return;
      }

      const userJid = message.key.participant || '';
      if (!await canUseCommand(sock, groupJid, userJid, 'admin')) {
        await sock.sendMessage(groupJid, { 
          text: 'Eita, amor! üö´ Esse comando √© s√≥ pra admins. Voc√™ n√£o tem essa permiss√£o ainda.' 
        });
        return;
      }

      const gameType = args[0]?.toLowerCase();
      const action = args[1]?.toLowerCase();

      // Se n√£o especificou jogo ou a√ß√£o, mostrar lista de brincadeiras
      if (!gameType) {
        await this.showBrincadeirasList(sock, message, groupJid);
        return;
      }

      if (gameType !== 'ppp' && gameType !== 'confissao') {
        await sock.sendMessage(groupJid, { 
          text: 'Eita, baby! ü´£ Por enquanto s√≥ temos o jogo PPP (Pego, Penso ou Passo) e Confiss√£o (Confession√°rio An√¥nimo)! üíã\n\n' +
                'Use:\n' +
                '‚Ä¢ !brincadeira ppp - Para jogos PPP\n' +
                '‚Ä¢ !brincadeira confissao - Para confession√°rio an√¥nimo' 
        });
        return;
      }

      if (gameType === 'ppp') {
        if (action === 'ativar') {
          await this.activateGame(sock, message, groupJid, userJid);
        } else if (action === 'enviar') {
          await this.sendSubmissions(sock, message, groupJid, userJid);
        } else if (action === 'status') {
          await this.getGameStatus(sock, message, groupJid);
        } else if (action === 'cancelar') {
          await this.cancelGame(sock, message, groupJid, userJid);
        } else if (action === 'encerrar') {
          await this.finalizeGame(sock, message, groupJid, userJid);
        } else if (action === 'debug') {
          await this.debugGame(sock, message, groupJid, userJid);
        } else if (action === 'ranking') {
          await this.getRanking(sock, message, groupJid);
        } else if (action === 'casais') {
          await this.getMatches(sock, message, groupJid);
        } else if (action === 'resultado') {
          await this.getResults(sock, message, groupJid, userJid);
        } else if (action === 'lista') {
          await this.getDetailedList(sock, message, groupJid, userJid);
        } else {
          await this.showHelp(sock, message, groupJid);
        }
      } else if (gameType === 'confissao') {
        if (action === 'ativar') {
          await ConfessionGame.activate(sock, message, groupJid, userJid, this.gameService);
        } else if (action === 'revelar') {
          await ConfessionGame.reveal(sock, message, groupJid, userJid, this.gameService);
        } else if (action === 'status') {
          await ConfessionGame.getStatus(sock, message, groupJid, this.gameService);
        } else if (action === 'cancelar') {
          await ConfessionGame.cancel(sock, message, groupJid, userJid, this.gameService);
        } else if (action === 'encerrar') {
          await ConfessionGame.finalize(sock, message, groupJid, userJid, this.gameService);
        } else if (action === 'ranking') {
          await ConfessionGame.ranking(sock, message, groupJid, this.gameService);
        } else if (action === 'chocantes') {
          await ConfessionGame.chocantes(sock, message, groupJid, this.gameService);
        } else if (action === 'micos') {
          await ConfessionGame.micos(sock, message, groupJid, this.gameService);
        } else if (action === 'resultado') {
          await ConfessionGame.resultado(sock, message, groupJid, userJid, this.gameService);
        } else {
          await ConfessionGame.showHelp(sock, message, groupJid);
        }
      }

    } catch (error) {
      console.error('[ERROR] Erro no comando brincadeira:', error);
      await sock.sendMessage(message.key.remoteJid!, { 
        text: 'Eita, baby! ü´£ Deu um erro inesperado no jogo! Tenta de novo! Se n√£o funcionar, chama o meu criador: +55 21 6723-3931 - ele vai resolver! üîß' 
      });
    }
  }

  private async activateGame(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      // Verificar se j√° existe um jogo ativo
      const existingGame = await this.gameService.findActiveGameByGroupId(groupJid);
      if (existingGame) {
        await sock.sendMessage(groupJid, { 
          text: 'Eita, baby! ü´£ J√° tem um jogo PPP ativo! Use !brincadeira ppp enviar para revelar as fotos! üíã' 
        });
        return;
      }

      // Finalizar qualquer jogo anterior (inativo) para limpar dados antigos
      const lastGame = await this.gameService.findLastGameByGroupId(groupJid);
      if (lastGame && lastGame.isActive === false) {
        // Jogo j√° est√° inativo, n√£o precisa fazer nada
        console.log('[DEBUG] Jogo anterior j√° est√° inativo');
      }

      // Obter nome do grupo
      const groupMetadata = await sock.groupMetadata(groupJid);
      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);

      // Criar o jogo
      await this.gameService.createGame(groupJid, userJid, groupMetadata.subject);

      const activationMessage = `üî• *JOGO PPP ATIVADO!* üî•\n\n` +
                               `üëë @${adminName} ativou o jogo *Pego, Penso ou Passo*!\n\n` +
                               `üì± *Como participar:*\n` +
                               `‚Ä¢ Me envie sua melhor foto no privado aqui pra mim (@Amanda)!\n` +
                               `‚Ä¢ Adicione uma frase de efeito na legenda\n` +
                               `‚Ä¢ Aguarde a revela√ß√£o no grupo!\n\n` +
                               `üíã *Regras:*\n` +
                               `‚Ä¢ S√≥ fotos suas (nada de fotos de outras pessoas)\n` +
                               `‚Ä¢ Frases criativas e engra√ßadas\n` +
                               `‚Ä¢ Uma foto por pessoa\n\n` +
                               `‚è∞ *Prazo:* At√© o admin usar !brincadeira ppp enviar\n\n` +
                               `_Vamos ver quem vai brilhar mais! üòà_`;

      await sock.sendMessage(groupJid, { 
        text: activationMessage,
        mentions: [userJid]
      });

    } catch (error) {
      console.error('[ERROR] Erro ao ativar jogo:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao ativar o jogo! Tenta de novo! Se n√£o funcionar, chama o meu criador: +55 21 6723-3931 - ele vai resolver! üîß' 
      });
    }
  }

  private async sendSubmissions(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      const submissions = await this.gameService.getSubmissions(groupJid);
      
      if (submissions.length === 0) {
        await sock.sendMessage(groupJid, { 
          text: 'U√©, ningu√©m teve coragem? ü§∑‚Äç‚ôÄÔ∏è A fila t√° vazia, ningu√©m me mandou foto no privado pra esse jogo. Que sem gra√ßa! üòí' 
        });
        return;
      }

      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);
      
      await sock.sendMessage(groupJid, { 
        text: `üé≠ *REVELA√á√ÉO DO JOGO PPP!* üé≠\n\n` +
              `üëë @${adminName} vai revelar ${submissions.length} foto(s)!\n\n` +
              `_Preparados para julgar? üòà_`,
        mentions: [userJid]
      });

      // Aguardar um pouco antes de come√ßar
      await new Promise(resolve => setTimeout(resolve, 3000));

      // Enviar cada submiss√£o
      for (let i = 0; i < submissions.length; i++) {
        const submission = submissions[i];
        
        try {
          // Verificar se o arquivo existe
          if (!fs.existsSync(submission.photoUrl)) {
            console.log(`[WARN] Arquivo n√£o encontrado: ${submission.photoUrl}`);
            continue;
          }

          const photoBuffer = fs.readFileSync(submission.photoUrl);
          const userNumber = submission.senderJid.split('@')[0];
          
          const caption = `üé≠ *PR√ìXIMA BELDADE NA PISTA!* üé≠\n\n` +
                         `üë§ @${userNumber}\n\n` +
                         `üí¨ *"${submission.caption || 'Sem legenda'}"*\n\n` +
                         `ü§î *E a√≠, galera? Reajam na foto:*\n` +
                         `üòè Pego | ü§î Penso | üòµ‚Äçüí´ Passo\n\n` +
                         `_Foto ${i + 1} de ${submissions.length}_`;

          await sock.sendMessage(groupJid, {
            image: photoBuffer,
            caption: caption,
            mentions: [submission.senderJid]
          });

          // Aguardar 30 segundos entre as fotos
          if (i < submissions.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 30000));
          }

        } catch (error) {
          console.error(`[ERROR] Erro ao enviar submiss√£o ${i + 1}:`, error);
        }
      }

      // Finalizar o jogo
      await this.gameService.clearSubmissions(groupJid);

      await sock.sendMessage(groupJid, { 
        text: `üéâ *JOGO PPP FINALIZADO!* üéâ\n\n` +
              `‚úÖ ${submissions.length} foto(s) revelada(s)\n` +
              `üî• Espero que tenham aproveitado...\n` +
              `üíã E que os 'Pegos' rendam um bom papo no privado! üòè\n\n` +
              `üìä *Comandos dispon√≠veis:*\n` +
              `‚Ä¢ !brincadeira ppp ranking - Ver ranking\n` +
              `‚Ä¢ !brincadeira ppp casais - Ver casais\n` +
              `‚Ä¢ !brincadeira ppp resultado - Resultado completo\n` +
              `‚Ä¢ !brincadeira ppp lista - Lista detalhada\n\n` +
              `_At√© a pr√≥xima! üî•_` 
      });

    } catch (error) {
      console.error('[ERROR] Erro ao enviar submiss√µes:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao enviar as fotos! Tenta de novo! üíã' 
      });
    }
  }

  private async getGameStatus(sock: WASocket, message: WAMessage, groupJid: string): Promise<void> {
    try {
      const game = await this.gameService.findActiveGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üìä *STATUS DO JOGO PPP*\n\n‚ùå Nenhum jogo ativo no momento.' 
        });
        return;
      }

      const stats = await this.gameService.getGameStats(groupJid);
      
      const statusMessage = `üìä *STATUS DO JOGO PPP*\n\n` +
                           `üü¢ *Status:* Ativo\n` +
                           `üì∏ *Fotos recebidas:* ${stats.totalSubmissions}\n` +
                           `üë• *Participantes:* ${stats.participants.length}\n` +
                           `‚è∞ *Criado em:* ${game.createdAt.toLocaleString('pt-BR')}\n\n` +
                           `_Use !brincadeira ppp enviar para revelar as fotos!_`;

      await sock.sendMessage(groupJid, { 
        text: statusMessage
      });

    } catch (error) {
      console.error('[ERROR] Erro ao obter status:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao verificar o status! üíã' 
      });
    }
  }

  private async cancelGame(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      const game = await this.gameService.findActiveGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'Eita, baby! ü´£ N√£o h√° jogo ativo para cancelar! üíã' 
        });
        return;
      }

      const stats = await this.gameService.getGameStats(groupJid);
      await this.gameService.clearSubmissions(groupJid);

      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);

      await sock.sendMessage(groupJid, { 
        text: `üõë *JOGO PPP CANCELADO!* üõë\n\n` +
              `üëë @${adminName} cancelou o jogo\n` +
              `üì∏ ${stats.totalSubmissions} foto(s) descartada(s)\n` +
              `üë• ${stats.participants.length} participante(s) afetado(s)\n\n` +
              `_Jogo encerrado sem revela√ß√£o._`,
        mentions: [userJid]
      });

    } catch (error) {
      console.error('[ERROR] Erro ao cancelar jogo:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao cancelar o jogo! üíã' 
      });
    }
  }

  private async showHelp(sock: WASocket, message: WAMessage, groupJid: string): Promise<void> {
    const helpMessage = `üéÆ *COMANDO BRINCADEIRA - AJUDA* üéÆ\n\n` +
                        `üìù *Jogos dispon√≠veis:*\n` +
                        `üé≠ *PPP (Pego, Penso ou Passo):*\n` +
                        `‚Ä¢ üî• !brincadeira ppp ativar - Ativa o jogo PPP\n` +
                        `‚Ä¢ üé≠ !brincadeira ppp enviar - Revela as fotos\n` +
                        `‚Ä¢ üìä !brincadeira ppp status - Status do jogo\n` +
                        `‚Ä¢ üõë !brincadeira ppp cancelar - Cancela o jogo\n` +
                        `‚Ä¢ üö´ !brincadeira ppp encerrar - Finaliza o jogo\n` +
                        `‚Ä¢ üèÜ !brincadeira ppp ranking - Ver ranking dos mais pegos\n` +
                        `‚Ä¢ üíï !brincadeira ppp casais - Ver casais formados\n` +
                        `‚Ä¢ üìà !brincadeira ppp resultado - Resultado completo\n` +
                        `‚Ä¢ üìã !brincadeira ppp lista - Lista detalhada (privado)\n` +
                        `\n` +
                        `ü§´ *Confession√°rio An√¥nimo:*\n` +
                        `‚Ä¢ ü§´ !brincadeira confissao ativar - Ativa o confession√°rio\n` +
                        `‚Ä¢ üé≠ !brincadeira confissao revelar - Revela as confiss√µes\n` +
                        `‚Ä¢ üìä !brincadeira confissao status - Status do confession√°rio\n` +
                        `‚Ä¢ üõë !brincadeira confissao cancelar - Cancela o confession√°rio\n` +
                        `‚Ä¢ üö´ !brincadeira confissao encerrar - Finaliza o confession√°rio\n` +
                        `‚Ä¢ üèÜ !brincadeira confissao ranking - Ver ranking dos populares\n` +
                        `‚Ä¢ üò± !brincadeira confissao chocantes - Ver confiss√µes chocantes\n` +
                        `‚Ä¢ üòÇ !brincadeira confissao micos - Ver maiores micos\n` +
                        `‚Ä¢ üìà !brincadeira confissao resultado - Resultado completo (privado)\n` +
                        `\n` +
                        `üéÆ *Como funcionam:*\n` +
                        `üé≠ *PPP:* Usu√°rios enviam fotos no privado, admin revela, galera reage\n` +
                        `ü§´ *Confession√°rio:* Usu√°rios enviam confiss√µes no privado, admin revela anonimamente\n` +
                        `\n` +
                        `‚ö†Ô∏è *ATEN√á√ÉO:* Apenas admins podem usar estes comandos!`;

    await sock.sendMessage(groupJid, { 
      text: helpMessage
    });
  }

  private async getRanking(sock: WASocket, message: WAMessage, groupJid: string): Promise<void> {
    try {
      const game = await this.gameService.findLastGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üìä *RANKING PPP*\n\n‚ùå Nenhum jogo encontrado.' 
        });
        return;
      }

      // Obter nomes dos usu√°rios
      const userNames = new Map<string, string>();
      try {
        const groupMetadata = await sock.groupMetadata(groupJid);
        groupMetadata.participants.forEach(participant => {
          userNames.set(participant.id, participant.name || participant.id.split('@')[0]);
        });
      } catch (error) {
        console.error('[ERROR] Erro ao obter nomes dos usu√°rios:', error);
      }

      const ranking = await this.gameService.getRanking(groupJid, userNames);
      
      if (ranking.length === 0) {
        await sock.sendMessage(groupJid, { 
          text: 'üìä *RANKING PPP*\n\nüòè Nenhuma rea√ß√£o "Pego" registrada ainda!' 
        });
        return;
      }

      let rankingMessage = `üèÜ *RANKING PPP - TOP PEGOS* üèÜ\n\n`;
      rankingMessage += `üìÖ *Jogo de:* ${game.createdAt.toLocaleString('pt-BR')}\n\n`;
      
      // Mostra top 5
      const top5 = ranking.slice(0, 5);
      top5.forEach((user, index) => {
        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üèÖ';
        rankingMessage += `${medal} *${index + 1}¬∫ Lugar:* ${user.userName}\n`;
        rankingMessage += `   üòè ${user.pegoCount} pego(s)\n\n`;
      });

      if (ranking.length > 5) {
        rankingMessage += `_... e mais ${ranking.length - 5} participantes!_`;
      }

      await sock.sendMessage(groupJid, { 
        text: rankingMessage
      });

    } catch (error) {
      console.error('[ERROR] Erro ao obter ranking:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao gerar o ranking! üíã' 
      });
    }
  }

  private async getMatches(sock: WASocket, message: WAMessage, groupJid: string): Promise<void> {
    try {
      const game = await this.gameService.findLastGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üíï *CASAIS PPP*\n\n‚ùå Nenhum jogo encontrado.' 
        });
        return;
      }

      // Obter nomes dos usu√°rios
      const userNames = new Map<string, string>();
      try {
        const groupMetadata = await sock.groupMetadata(groupJid);
        groupMetadata.participants.forEach(participant => {
          userNames.set(participant.id, participant.name || participant.id.split('@')[0]);
        });
      } catch (error) {
        console.error('[ERROR] Erro ao obter nomes dos usu√°rios:', error);
      }

      const matches = await this.gameService.getMatches(groupJid, userNames);
      
      if (matches.length === 0) {
        await sock.sendMessage(groupJid, { 
          text: 'üíï *CASAIS PPP*\n\nüòî Nenhum casal formado ainda! Ningu√©m marcou "Pego" m√∫tuo.' 
        });
        return;
      }

      let matchesMessage = `üíï *CASAIS FORMADOS - PPP* üíï\n\n`;
      matchesMessage += `üìÖ *Jogo de:* ${game.createdAt.toLocaleString('pt-BR')}\n`;
      matchesMessage += `üî• *${matches.length} casal(is) encontrado(s):*\n\n`;
      
      matches.forEach((match, index) => {
        matchesMessage += `üíò *Casal ${index + 1}:*\n`;
        matchesMessage += `   üë´ ${match.user1Name} + ${match.user2Name}\n`;
        matchesMessage += `   üòè Pego m√∫tuo confirmado!\n\n`;
      });

      matchesMessage += `_Que romance! üíã_`;

      await sock.sendMessage(groupJid, { 
        text: matchesMessage
      });

    } catch (error) {
      console.error('[ERROR] Erro ao obter casais:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao encontrar os casais! üíã' 
      });
    }
  }

  private async getResults(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      const game = await this.gameService.findLastGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üìä *RESULTADO PPP*\n\n‚ùå Nenhum jogo encontrado.' 
        });
        return;
      }

      // Obter nomes dos usu√°rios
      const userNames = new Map<string, string>();
      try {
        const groupMetadata = await sock.groupMetadata(groupJid);
        groupMetadata.participants.forEach(participant => {
          userNames.set(participant.id, participant.name || participant.id.split('@')[0]);
        });
      } catch (error) {
        console.error('[ERROR] Erro ao obter nomes dos usu√°rios:', error);
      }

      const ranking = await this.gameService.getRanking(groupJid, userNames);
      const matches = await this.gameService.getMatches(groupJid, userNames);
      const reactions = await this.gameService.getReactions(groupJid);
      
      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);

      let resultsMessage = `üéâ *RESULTADO FINAL - JOGO PPP* üéâ\n\n`;
      resultsMessage += `üëë @${adminName} apresenta os resultados!\n`;
      resultsMessage += `üìÖ *Data do jogo:* ${game.createdAt.toLocaleString('pt-BR')}\n\n`;
      
      // Estat√≠sticas gerais
      const pegoCount = reactions.filter(r => r.reactionType === 'pego').length;
      const totalReactions = reactions.length;
      
      resultsMessage += `üìä *ESTAT√çSTICAS:*\n`;
      resultsMessage += `üì∏ Fotos reveladas: ${game.submissions.length}\n`;
      resultsMessage += `üòè Total de "Pego": ${pegoCount}\n`;
      resultsMessage += `üíï Casais formados: ${matches.length}\n\n`;

      // Top 3 do ranking
      if (ranking.length > 0) {
        resultsMessage += `üèÜ *TOP 3 MAIS PEGOS:*\n`;
        const top3 = ranking.slice(0, 3);
        top3.forEach((user, index) => {
          const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';
          resultsMessage += `${medal} ${user.userName} (${user.pegoCount} pego(s))\n`;
        });
        resultsMessage += `\n`;
      }

      // Casais formados
      if (matches.length > 0) {
        resultsMessage += `üíï *CASAIS FORMADOS:*\n`;
        matches.forEach((match, index) => {
          resultsMessage += `üíò ${match.user1Name} + ${match.user2Name}\n`;
        });
        resultsMessage += `\n`;
      }

      resultsMessage += `_Parab√©ns a todos os participantes! üî•_`;

      await sock.sendMessage(groupJid, { 
        text: resultsMessage,
        mentions: [userJid]
      });

    } catch (error) {
      console.error('[ERROR] Erro ao obter resultados:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao gerar os resultados! üíã' 
      });
    }
  }

  private async getDetailedList(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      const game = await this.gameService.findLastGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üìã *LISTA DETALHADA PPP*\n\n‚ùå Nenhum jogo encontrado.' 
        });
        return;
      }

      // Obter nomes dos usu√°rios
      const userNames = new Map<string, string>();
      try {
        const groupMetadata = await sock.groupMetadata(groupJid);
        groupMetadata.participants.forEach(participant => {
          userNames.set(participant.id, participant.name || participant.id.split('@')[0]);
        });
      } catch (error) {
        console.error('[ERROR] Erro ao obter nomes dos usu√°rios:', error);
      }

      const detailedList = await this.gameService.getDetailedReactionsList(groupJid, userNames);
      
      // Enviar no privado do admin
      await sock.sendMessage(userJid, { 
        text: detailedList
      });

      // Confirmar no grupo
      await sock.sendMessage(groupJid, { 
        text: `üìã *LISTA DETALHADA PPP*\n\n‚úÖ Lista enviada no seu privado, @${userJid.split('@')[0]}!`,
        mentions: [userJid]
      });

    } catch (error) {
      console.error('[ERROR] Erro ao obter lista detalhada:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao gerar a lista detalhada! üíã' 
      });
    }
  }

  private async finalizeGame(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      const game = await this.gameService.findActiveGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'Eita, baby! ü´£ N√£o h√° jogo ativo para finalizar! üíã' 
        });
        return;
      }

      const stats = await this.gameService.getGameStats(groupJid);
      await this.gameService.clearSubmissions(groupJid);
      await this.gameService.endGame(groupJid);

      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);

      await sock.sendMessage(groupJid, { 
        text: `üõë *JOGO PPP FINALIZADO!* üõë\n\n` +
              `üëë @${adminName} finalizou o jogo\n` +
              `üì∏ ${stats.totalSubmissions} foto(s) descartada(s)\n` +
              `üë• ${stats.participants.length} participante(s) afetado(s)\n\n` +
              `_Jogo encerrado sem revela√ß√£o._`,
        mentions: [userJid]
      });

    } catch (error) {
      console.error('[ERROR] Erro ao finalizar jogo:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao finalizar o jogo! üíã' 
      });
    }
  }

  private async debugGame(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      const game = await this.gameService.findLastGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üîç *DEBUG PPP*\n\n‚ùå Nenhum jogo encontrado.' 
        });
        return;
      }

      const reactions = await this.gameService.getReactions(groupJid);
      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);

      let debugMessage = `üîç *DEBUG PPP - DADOS DO JOGO* üîç\n\n`;
      debugMessage += `üëë @${adminName} solicitou debug\n\n`;
      debugMessage += `üìä *INFORMA√á√ïES DO JOGO:*\n`;
      debugMessage += `üÜî ID: ${game._id}\n`;
      debugMessage += `üìÖ Criado em: ${game.createdAt.toLocaleString('pt-BR')}\n`;
      debugMessage += `üì∏ Fotos: ${game.submissions.length}\n`;
      debugMessage += `üí¨ Rea√ß√µes: ${reactions.length}\n`;
      debugMessage += `üü¢ Ativo: ${game.isActive ? 'Sim' : 'N√£o'}\n\n`;

      if (reactions.length > 0) {
        debugMessage += `üìã *DETALHES DAS REA√á√ïES:*\n`;
        reactions.forEach((reaction, index) => {
          debugMessage += `${index + 1}. ${reaction.reactorJid} -> ${reaction.reactionType}\n`;
        });
      } else {
        debugMessage += `üìã *REA√á√ïES:* Nenhuma rea√ß√£o registrada\n`;
      }

      // Enviar no privado do admin
      await sock.sendMessage(userJid, { 
        text: debugMessage
      });

      // Confirmar no grupo
      await sock.sendMessage(groupJid, { 
        text: `üîç *DEBUG PPP*\n\n‚úÖ Debug enviado no seu privado, @${userJid.split('@')[0]}!`,
        mentions: [userJid]
      });

    } catch (error) {
      console.error('[ERROR] Erro ao executar debug:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao executar o debug! üíã' 
      });
    }
  }

  private async activateConfessionGame(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      // Verificar se j√° existe um jogo ativo
      const existingGame = await this.gameService.findActiveConfessionGameByGroupId(groupJid);
      if (existingGame) {
        await sock.sendMessage(groupJid, { 
          text: 'Eita, baby! ü´£ J√° tem um Confession√°rio ativo! Use !brincadeira confissao revelar para revelar as confiss√µes! üíã' 
        });
        return;
      }

      // Obter nome do grupo
      const groupMetadata = await sock.groupMetadata(groupJid);
      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);

      // Criar o jogo
      await this.gameService.createConfessionGame(groupJid, userJid, groupMetadata.subject);

      const activationMessage = `ü§´ *CONFESSION√ÅRIO ABERTO!* ü§´\n\n` +
                               `üëë @${adminName} abriu o confession√°rio an√¥nimo!\n\n` +
                               `üì± *Como participar:*\n` +
                               `‚Ä¢ Me envie uma confiss√£o no privado aqui pra mim (@Amanda)!\n` +
                               `‚Ä¢ Pode ser um segredo, um mico ou uma frase "Eu Nunca..."\n` +
                               `‚Ä¢ Seja criativo e honesto (mas pegue leve!)\n\n` +
                               `üí¨ *Exemplos:*\n` +
                               `‚Ä¢ "Eu j√° comi pizza com ketchup."\n` +
                               `‚Ä¢ "Eu nunca colei em uma prova."\n` +
                               `‚Ä¢ "Uma vez, chamei a sogra pelo nome da ex."\n\n` +
                               `‚è∞ *Prazo:* At√© o admin usar !brincadeira confissao revelar\n\n` +
                               `_Vamos ver quem vai se revelar mais! üòà_`;

      await sock.sendMessage(groupJid, { 
        text: activationMessage,
        mentions: [userJid]
      });

    } catch (error) {
      console.error('[ERROR] Erro ao ativar jogo de confiss√£o:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao ativar o confession√°rio! Tenta de novo! Se n√£o funcionar, chama o meu criador: +55 21 6723-3931 - ele vai resolver! üîß' 
      });
    }
  }

  private async revealConfessions(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      const confessions = await this.gameService.getConfessions(groupJid);
      
      if (confessions.length === 0) {
        await sock.sendMessage(groupJid, { 
          text: 'U√©, ningu√©m teve coragem de confessar? ü§∑‚Äç‚ôÄÔ∏è A fila t√° vazia, ningu√©m me mandou confiss√£o no privado pra esse jogo. Que sem gra√ßa! üòí' 
        });
        return;
      }

      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);
      
      await sock.sendMessage(groupJid, { 
        text: `ü§´ *REVELA√á√ÉO DO CONFESSION√ÅRIO!* ü§´\n\n` +
              `üëë @${adminName} vai revelar ${confessions.length} confiss√£o(√µes)!\n\n` +
              `_Preparados para se chocar? üòà_`,
        mentions: [userJid]
      });

      // Aguardar um pouco antes de come√ßar
      await new Promise(resolve => setTimeout(resolve, 3000));

      // Enviar cada confiss√£o
      for (let i = 0; i < confessions.length; i++) {
        const confession = confessions[i];
        
        const confessionMessage = `ü§´ *CONFISS√ÉO AN√îNIMA #${i + 1}* ü§´\n\n` +
                                 `üí¨ *"${confession.confession}"*\n\n` +
                                 `ü§î *E a√≠, galera? Reajam na confiss√£o:*\n` +
                                 `üôã‚Äç‚ôÇÔ∏è Eu Tamb√©m! | üò± Chocado(a)! | üòÇ Que Mico!\n\n` +
                                 `_Confiss√£o ${i + 1} de ${confessions.length}_`;

        await sock.sendMessage(groupJid, {
          text: confessionMessage
        });

        // Aguardar 30 segundos entre as confiss√µes
        if (i < confessions.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 30000));
        }
      }

      // Finalizar o jogo
      await this.gameService.clearConfessions(groupJid);

      await sock.sendMessage(groupJid, { 
        text: `üéâ *CONFESSION√ÅRIO FINALIZADO!* üéâ\n\n` +
              `‚úÖ ${confessions.length} confiss√£o(√µes) revelada(s)\n` +
              `üî• Espero que tenham aproveitado...\n` +
              `üíã E que as confiss√µes rendam um bom papo! üòè\n\n` +
              `üìä *Comandos dispon√≠veis:*\n` +
              `‚Ä¢ !brincadeira confissao ranking - Ver ranking\n` +
              `‚Ä¢ !brincadeira confissao chocantes - Ver chocantes\n` +
              `‚Ä¢ !brincadeira confissao micos - Ver micos\n` +
              `‚Ä¢ !brincadeira confissao resultado - Resultado completo\n\n` +
              `_At√© a pr√≥xima! üî•_` 
      });

    } catch (error) {
      console.error('[ERROR] Erro ao revelar confiss√µes:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao revelar as confiss√µes! Tenta de novo! üíã' 
      });
    }
  }

  private async getConfessionGameStatus(sock: WASocket, message: WAMessage, groupJid: string): Promise<void> {
    try {
      const game = await this.gameService.findActiveConfessionGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üìä *STATUS DO CONFESSION√ÅRIO*\n\n‚ùå Nenhum confession√°rio ativo no momento.' 
        });
        return;
      }

      const stats = await this.gameService.getConfessionGameStats(groupJid);
      
      const statusMessage = `üìä *STATUS DO CONFESSION√ÅRIO*\n\n` +
                           `üü¢ *Status:* Ativo\n` +
                           `ü§´ *Confiss√µes recebidas:* ${stats.totalConfessions}\n` +
                           `üë• *Participantes:* ${stats.participants.length}\n` +
                           `‚è∞ *Criado em:* ${game.createdAt.toLocaleString('pt-BR')}\n\n` +
                           `_Use !brincadeira confissao revelar para revelar as confiss√µes!_`;

      await sock.sendMessage(groupJid, { 
        text: statusMessage
      });

    } catch (error) {
      console.error('[ERROR] Erro ao obter status do confession√°rio:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao verificar o status! üíã' 
      });
    }
  }

  private async cancelConfessionGame(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      const game = await this.gameService.findActiveConfessionGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'Eita, baby! ü´£ N√£o h√° confession√°rio ativo para cancelar! üíã' 
        });
        return;
      }

      const stats = await this.gameService.getConfessionGameStats(groupJid);
      await this.gameService.clearConfessions(groupJid);

      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);

      await sock.sendMessage(groupJid, { 
        text: `üõë *CONFESSION√ÅRIO CANCELADO!* üõë\n\n` +
              `üëë @${adminName} cancelou o confession√°rio\n` +
              `ü§´ ${stats.totalConfessions} confiss√£o(√µes) descartada(s)\n` +
              `üë• ${stats.participants.length} participante(s) afetado(s)\n\n` +
              `_Confession√°rio encerrado sem revela√ß√£o._`,
        mentions: [userJid]
      });

    } catch (error) {
      console.error('[ERROR] Erro ao cancelar confession√°rio:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao cancelar o confession√°rio! üíã' 
      });
    }
  }

  private async finalizeConfessionGame(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      const game = await this.gameService.findActiveConfessionGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'Eita, baby! ü´£ N√£o h√° confession√°rio ativo para finalizar! üíã' 
        });
        return;
      }

      const stats = await this.gameService.getConfessionGameStats(groupJid);
      await this.gameService.clearConfessions(groupJid);
      await this.gameService.endConfessionGame(groupJid);

      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);

      await sock.sendMessage(groupJid, { 
        text: `üõë *CONFESSION√ÅRIO FINALIZADO!* üõë\n\n` +
              `üëë @${adminName} finalizou o confession√°rio\n` +
              `ü§´ ${stats.totalConfessions} confiss√£o(√µes) descartada(s)\n` +
              `üë• ${stats.participants.length} participante(s) afetado(s)\n\n` +
              `_Confession√°rio encerrado sem revela√ß√£o._`,
        mentions: [userJid]
      });

    } catch (error) {
      console.error('[ERROR] Erro ao finalizar confession√°rio:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao finalizar o confession√°rio! üíã' 
      });
    }
  }

  private async getConfessionRanking(sock: WASocket, message: WAMessage, groupJid: string): Promise<void> {
    try {
      const game = await this.gameService.findLastConfessionGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üìä *RANKING DO CONFESSION√ÅRIO*\n\n‚ùå Nenhum confession√°rio encontrado.' 
        });
        return;
      }

      const ranking = await this.gameService.getConfessionRanking(groupJid);
      
      if (ranking.length === 0) {
        await sock.sendMessage(groupJid, { 
          text: 'üìä *RANKING DO CONFESSION√ÅRIO*\n\nüôã‚Äç‚ôÇÔ∏è Nenhuma rea√ß√£o "Eu Tamb√©m!" registrada ainda!' 
        });
        return;
      }

      let rankingMessage = `üèÜ *RANKING CONFESSION√ÅRIO - TOP POPULARES* üèÜ\n\n`;
      rankingMessage += `üìÖ *Confession√°rio de:* ${game.createdAt.toLocaleString('pt-BR')}\n\n`;
      
      // Mostra top 3
      const top3 = ranking.slice(0, 3);
      top3.forEach((confession, index) => {
        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';
        rankingMessage += `${medal} *${index + 1}¬∫ Lugar:*\n`;
        rankingMessage += `   üí¨ "${confession.confession}"\n`;
        rankingMessage += `   üôã‚Äç‚ôÇÔ∏è ${confession.euTambemCount} "Eu Tamb√©m!"\n\n`;
      });

      if (ranking.length > 3) {
        rankingMessage += `_... e mais ${ranking.length - 3} confiss√µes!_`;
      }

      await sock.sendMessage(groupJid, { 
        text: rankingMessage
      });

    } catch (error) {
      console.error('[ERROR] Erro ao obter ranking do confession√°rio:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao gerar o ranking! üíã' 
      });
    }
  }

  private async getShockingConfessions(sock: WASocket, message: WAMessage, groupJid: string): Promise<void> {
    try {
      const game = await this.gameService.findLastConfessionGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üò± *CONFISS√ïES CHOCANTES*\n\n‚ùå Nenhum confession√°rio encontrado.' 
        });
        return;
      }

      const shocking = await this.gameService.getShockingConfessions(groupJid);
      
      if (shocking.length === 0) {
        await sock.sendMessage(groupJid, { 
          text: 'üò± *CONFISS√ïES CHOCANTES*\n\nüò± Nenhuma rea√ß√£o "Chocado(a)!" registrada ainda!' 
        });
        return;
      }

      let shockingMessage = `üò± *CONFISS√ïES MAIS CHOCANTES* üò±\n\n`;
      shockingMessage += `üìÖ *Confession√°rio de:* ${game.createdAt.toLocaleString('pt-BR')}\n\n`;
      
      // Mostra top 3
      const top3 = shocking.slice(0, 3);
      top3.forEach((confession, index) => {
        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';
        shockingMessage += `${medal} *${index + 1}¬∫ Lugar:*\n`;
        shockingMessage += `   üí¨ "${confession.confession}"\n`;
        shockingMessage += `   üò± ${confession.chocadoCount} "Chocado(a)!"\n\n`;
      });

      if (shocking.length > 3) {
        shockingMessage += `_... e mais ${shocking.length - 3} confiss√µes chocantes!_`;
      }

      await sock.sendMessage(groupJid, { 
        text: shockingMessage
      });

    } catch (error) {
      console.error('[ERROR] Erro ao obter confiss√µes chocantes:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao buscar as confiss√µes chocantes! üíã' 
      });
    }
  }

  private async getFunnyConfessions(sock: WASocket, message: WAMessage, groupJid: string): Promise<void> {
    try {
      const game = await this.gameService.findLastConfessionGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üòÇ *CONFISS√ïES ENGRA√áADAS*\n\n‚ùå Nenhum confession√°rio encontrado.' 
        });
        return;
      }

      const funny = await this.gameService.getFunnyConfessions(groupJid);
      
      if (funny.length === 0) {
        await sock.sendMessage(groupJid, { 
          text: 'üòÇ *CONFISS√ïES ENGRA√áADAS*\n\nüòÇ Nenhuma rea√ß√£o "Que Mico!" registrada ainda!' 
        });
        return;
      }

      let funnyMessage = `üòÇ *MAIORES MICOS DO CONFESSION√ÅRIO* üòÇ\n\n`;
      funnyMessage += `üìÖ *Confession√°rio de:* ${game.createdAt.toLocaleString('pt-BR')}\n\n`;
      
      // Mostra top 3
      const top3 = funny.slice(0, 3);
      top3.forEach((confession, index) => {
        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : 'ü•â';
        funnyMessage += `${medal} *${index + 1}¬∫ Lugar:*\n`;
        funnyMessage += `   üí¨ "${confession.confession}"\n`;
        funnyMessage += `   üòÇ ${confession.micoCount} "Que Mico!"\n\n`;
      });

      if (funny.length > 3) {
        funnyMessage += `_... e mais ${funny.length - 3} micos engra√ßados!_`;
      }

      await sock.sendMessage(groupJid, { 
        text: funnyMessage
      });

    } catch (error) {
      console.error('[ERROR] Erro ao obter confiss√µes engra√ßadas:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao buscar os micos! üíã' 
      });
    }
  }

  private async getConfessionResults(sock: WASocket, message: WAMessage, groupJid: string, userJid: string): Promise<void> {
    try {
      const game = await this.gameService.findLastConfessionGameByGroupId(groupJid);
      
      if (!game) {
        await sock.sendMessage(groupJid, { 
          text: 'üìä *RESULTADO DO CONFESSION√ÅRIO*\n\n‚ùå Nenhum confession√°rio encontrado.' 
        });
        return;
      }

      const ranking = await this.gameService.getConfessionRanking(groupJid);
      const shocking = await this.gameService.getShockingConfessions(groupJid);
      const funny = await this.gameService.getFunnyConfessions(groupJid);
      const reactions = await this.gameService.getConfessionReactions(groupJid);
      
      const adminName = await getUserDisplayName(sock, userJid, groupJid, message.pushName);

      let resultsMessage = `üéâ *RESULTADO FINAL - CONFESSION√ÅRIO* üéâ\n\n`;
      resultsMessage += `üëë @${adminName} apresenta os resultados!\n`;
      resultsMessage += `üìÖ *Data do confession√°rio:* ${game.createdAt.toLocaleString('pt-BR')}\n\n`;
      
      // Estat√≠sticas gerais
      const euTambemCount = reactions.filter(r => r.reactionType === 'euTambem').length;
      const chocadoCount = reactions.filter(r => r.reactionType === 'chocado').length;
      const micoCount = reactions.filter(r => r.reactionType === 'mico').length;
      const totalReactions = reactions.length;
      
      resultsMessage += `üìä *ESTAT√çSTICAS:*\n`;
      resultsMessage += `ü§´ Confiss√µes reveladas: ${game.confessions.length}\n`;
      resultsMessage += `üôã‚Äç‚ôÇÔ∏è Total de "Eu Tamb√©m!": ${euTambemCount}\n`;
      resultsMessage += `üò± Total de "Chocado(a)!": ${chocadoCount}\n`;
      resultsMessage += `üòÇ Total de "Que Mico!": ${micoCount}\n\n`;

      // Top confiss√£o popular
      if (ranking.length > 0) {
        resultsMessage += `üèÜ *CONFISS√ÉO MAIS POPULAR:*\n`;
        resultsMessage += `üí¨ "${ranking[0].confession}"\n`;
        resultsMessage += `üôã‚Äç‚ôÇÔ∏è ${ranking[0].euTambemCount} "Eu Tamb√©m!"\n\n`;
      }

      // Top confiss√£o chocante
      if (shocking.length > 0) {
        resultsMessage += `üò± *CONFISS√ÉO MAIS CHOCANTE:*\n`;
        resultsMessage += `üí¨ "${shocking[0].confession}"\n`;
        resultsMessage += `üò± ${shocking[0].chocadoCount} "Chocado(a)!"\n\n`;
      }

      // Top mico
      if (funny.length > 0) {
        resultsMessage += `üòÇ *MAIOR MICO:*\n`;
        resultsMessage += `üí¨ "${funny[0].confession}"\n`;
        resultsMessage += `üòÇ ${funny[0].micoCount} "Que Mico!"\n\n`;
      }

      resultsMessage += `_Parab√©ns a todos os corajosos que confessaram! üî•_`;

      // Enviar no privado do admin para n√£o expor ningu√©m
      await sock.sendMessage(userJid, { 
        text: resultsMessage
      });

      // Confirmar no grupo
      await sock.sendMessage(groupJid, { 
        text: `üìä *RESULTADO DO CONFESSION√ÅRIO*\n\n‚úÖ Resultado completo enviado no seu privado, @${userJid.split('@')[0]}!`,
        mentions: [userJid]
      });

    } catch (error) {
      console.error('[ERROR] Erro ao obter resultados do confession√°rio:', error);
      await sock.sendMessage(groupJid, { 
        text: 'Eita, baby! ü´£ Deu erro ao gerar os resultados! üíã' 
      });
    }
  }

  private async showConfessionHelp(sock: WASocket, message: WAMessage, groupJid: string): Promise<void> {
    const helpMessage = `ü§´ *COMANDO CONFESSION√ÅRIO - AJUDA* ü§´\n\n` +
                        `üìù *Como usar:*\n` +
                        `‚Ä¢ ü§´ !brincadeira confissao ativar - Ativa o confession√°rio\n` +
                        `‚Ä¢ üé≠ !brincadeira confissao revelar - Revela as confiss√µes\n` +
                        `‚Ä¢ üìä !brincadeira confissao status - Status do confession√°rio\n` +
                        `‚Ä¢ üõë !brincadeira confissao cancelar - Cancela o confession√°rio\n` +
                        `‚Ä¢ üö´ !brincadeira confissao encerrar - Finaliza o confession√°rio\n` +
                        `‚Ä¢ üèÜ !brincadeira confissao ranking - Ver ranking dos populares\n` +
                        `‚Ä¢ üò± !brincadeira confissao chocantes - Ver confiss√µes chocantes\n` +
                        `‚Ä¢ üòÇ !brincadeira confissao micos - Ver maiores micos\n` +
                        `‚Ä¢ üìà !brincadeira confissao resultado - Resultado completo (privado)\n` +
                        `\n` +
                        `ü§´ *Jogo Confession√°rio An√¥nimo:*\n` +
                        `‚Ä¢ Usu√°rios enviam confiss√µes no privado\n` +
                        `‚Ä¢ Admin revela as confiss√µes anonimamente\n` +
                        `‚Ä¢ Galera reage: Eu Tamb√©m! üôã‚Äç‚ôÇÔ∏è, Chocado(a)! üò±, Que Mico! üòÇ\n` +
                        `‚Ä¢ Dados ficam dispon√≠veis at√© novo jogo\n\n` +
                        `‚ö†Ô∏è *ATEN√á√ÉO:* Apenas admins podem usar este comando!`;

    await sock.sendMessage(groupJid, { 
      text: helpMessage
    });
  }

  private async showBrincadeirasList(sock: WASocket, message: WAMessage, groupJid: string): Promise<void> {
    const listMessage = `üéÆ *LISTA DE BRINCADEIRAS* üéÆ\n\n` +
                        `üé≠ *PPP (Pego, Penso ou Passo):\n` +
                        `‚Ä¢ üî• !brincadeira ppp ativar - Ativa o jogo PPP\n` +
                        `‚Ä¢ üé≠ !brincadeira ppp enviar - Revela as fotos\n` +
                        `‚Ä¢ üìä !brincadeira ppp status - Status do jogo\n` +
                        `‚Ä¢ üõë !brincadeira ppp cancelar - Cancela o jogo\n` +
                        `‚Ä¢ üö´ !brincadeira ppp encerrar - Finaliza o jogo\n` +
                        `‚Ä¢ üèÜ !brincadeira ppp ranking - Ver ranking dos mais pegos\n` +
                        `‚Ä¢ üíï !brincadeira ppp casais - Ver casais formados\n` +
                        `‚Ä¢ üìà !brincadeira ppp resultado - Resultado completo\n` +
                        `‚Ä¢ üìã !brincadeira ppp lista - Lista detalhada (privado)\n\n` +
                        `ü§´ *Confession√°rio An√¥nimo:\n` +
                        `‚Ä¢ ü§´ !brincadeira confissao ativar - Ativa o confession√°rio\n` +
                        `‚Ä¢ üé≠ !brincadeira confissao revelar - Revela as confiss√µes\n` +
                        `‚Ä¢ üìä !brincadeira confissao status - Status do confession√°rio\n` +
                        `‚Ä¢ üõë !brincadeira confissao cancelar - Cancela o confession√°rio\n` +
                        `‚Ä¢ üö´ !brincadeira confissao encerrar - Finaliza o confession√°rio\n` +
                        `‚Ä¢ üèÜ !brincadeira confissao ranking - Ver ranking dos populares\n` +
                        `‚Ä¢ üò± !brincadeira confissao chocantes - Ver confiss√µes chocantes\n` +
                        `‚Ä¢ üòÇ !brincadeira confissao micos - Ver maiores micos\n` +
                        `‚Ä¢ üìà !brincadeira confissao resultado - Resultado completo (privado)\n\n` +
                        `üéÆ *Como funcionam:\n` +
                        `üé≠ *PPP: Usu√°rios enviam fotos no privado, admin revela, galera reage\n` +
                        `ü§´ *Confession√°rio: Usu√°rios enviam confiss√µes no privado, admin revela anonimamente\n\n` +
                        `‚ö†Ô∏è *ATEN√á√ÉO: Apenas admins podem usar estes comandos!`;

    await sock.sendMessage(groupJid, { 
      text: listMessage
    });
  }
}

// Exportar fun√ß√µes para uso no MessageManager
export async function handlePrivatePhotoSubmission(
  sock: WASocket, 
  message: WAMessage, 
  userJid: string,
  gameService: GameService
): Promise<void> {
  try {
    // FIX: Melhorar filtro para ignorar status, broadcast, lid e newsletter
    if (
      userJid.endsWith('@status') ||
      userJid.endsWith('@broadcast') ||
      userJid.endsWith('@lid') ||
      userJid.endsWith('@newsletter') ||
      userJid.endsWith('@g.us')
    ) {
      console.log('[DEBUG] Ignorando mensagem de status/broadcast/lid/newsletter/grupo:', userJid);
      return;
    }

    // FIX: Verificar se a mensagem √© do pr√≥prio bot
    if (message.key.fromMe) {
      console.log('[DEBUG] Ignorando mensagem do pr√≥prio bot');
      return;
    }

    // FIX: Verificar se √© realmente uma imagem
    if (!message.message?.imageMessage) {
      console.log('[DEBUG] Mensagem n√£o cont√©m imagem, ignorando');
      return;
    }

    console.log(`[DEBUG] Processando foto privada de ${userJid}`);

    // Buscar jogos ativos para o usu√°rio
    const activeGames = await gameService.findActiveGamesForUser(userJid);
    
    if (activeGames.length === 0) {
      await sock.sendMessage(userJid, { 
        text: 'Uhm, gato(a), recebi sua foto, mas n√£o encontrei nenhum grupo seu onde o "Pego, Penso ou Passo" esteja rolando. Tem certeza que seu admin j√° ativou a brincadeira com !brincadeira ppp ativar? ü§î' 
      });
      return;
    }

    // Baixar e salvar a foto
    const photoPath = await downloadGamePhoto(sock, message, userJid);
    const caption = message.message?.imageMessage?.caption || '';

    // Buscar grupos onde o usu√°rio √© membro
    const userGroups = await Group.find({ members: userJid });
    const userGroupIds = userGroups.map(g => g.groupJid);

    // Filtrar jogos ativos onde o usu√°rio √© membro
    const userActiveGames = activeGames.filter(game => userGroupIds.includes(game.groupId));

    if (userActiveGames.length === 0) {
      await sock.sendMessage(userJid, { 
        text: 'Eita, baby! ü´£ Encontrei jogos PPP ativos, mas voc√™ n√£o √© membro de nenhum deles! Que estranho... üíã' 
      });
      return;
    }

    // Para cada jogo ativo, verificar se o criador tamb√©m √© membro
    const validGames: Array<{ game: any; groupName: string; isCreatorGroup: boolean }> = [];
    
    for (const game of userActiveGames) {
      try {
        const groupDoc = await Group.findOne({ groupJid: game.groupId });
        if (groupDoc && groupDoc.members.includes(game.createdBy)) {
          // Ambos s√£o membros do grupo
          validGames.push({
            game,
            groupName: game.groupName || groupDoc.name || 'Grupo Desconhecido',
            isCreatorGroup: true
          });
        }
      } catch (error) {
        console.error(`[ERROR] Erro ao verificar grupo ${game.groupId}:`, error);
      }
    }

    // Se n√£o encontrou grupos onde ambos s√£o membros, mostrar todos os grupos dispon√≠veis
    if (validGames.length === 0) {
      // Mostrar TODOS os jogos ativos dispon√≠veis, n√£o apenas os do usu√°rio
      const allAvailableGames = activeGames.map(game => ({
        game,
        groupName: game.groupName || 'Grupo Desconhecido',
        isCreatorGroup: false
      }));

      const options = allAvailableGames.map((game, index) => ({
        groupId: game.game.groupId,
        groupName: game.groupName,
        isCreatorGroup: false
      }));

      const choiceMessage = `Opa, que pessoa popular! üî• Vi que voc√™ t√° em grupos onde a brincadeira t√° rolando, mas n√£o encontrei o admin que criou o jogo. Aqui est√£o TODOS os grupos com brincadeira ativa. Para qual grupo voc√™ quer enviar essa foto? Responda com o n√∫mero:\n\n` +
                           options.map((option, index) => `${index + 1}. ${option.groupName}`).join('\n') +
                           `\n\n_Responda apenas com o n√∫mero (ex: 1, 2, 3...)_`;

      await sock.sendMessage(userJid, { 
        text: choiceMessage
      });

      // Salvar estado tempor√°rio
      pendingGroupChoices.set(userJid, {
        options,
        photoData: {
          messageId: message.key.id!,
          photoUrl: photoPath,
          caption
        },
        timestamp: Date.now(),
        step: 'choose'
      });

      // Limpar escolhas antigas (mais de 5 minutos)
      setTimeout(() => {
        pendingGroupChoices.delete(userJid);
      }, 5 * 60 * 1000);
      
      return;
    }

    // Se encontrou apenas um grupo v√°lido, confirmar
    if (validGames.length === 1) {
      const game = validGames[0];
      
      // Verificar se j√° enviou
      const hasSubmitted = await gameService.hasUserSubmitted(game.game.groupId, userJid);
      if (hasSubmitted) {
        await sock.sendMessage(userJid, { 
          text: 'Eita, baby! ü´£ Voc√™ j√° enviou uma foto para este jogo! S√≥ uma por pessoa, t√°? üíã' 
        });
        pendingGroupChoices.delete(userJid);
        return;
      }

      const confirmMessage = `Ui, que fot√£o! üòâ Encontrei o jogo PPP no grupo "${game.groupName}". Quer enviar sua foto para esse grupo?\n\n` +
                            `Responda:\n` +
                            `‚úÖ Sim / 1 - Para confirmar\n` +
                            `‚ùå N√£o / 2 - Para ver outras op√ß√µes`;

      await sock.sendMessage(userJid, { 
        text: confirmMessage
      });

      // Salvar estado tempor√°rio para confirma√ß√£o
      pendingGroupChoices.set(userJid, {
        options: [{
          groupId: game.game.groupId,
          groupName: game.groupName,
          isCreatorGroup: true
        }],
        photoData: {
          messageId: message.key.id!,
          photoUrl: photoPath,
          caption
        },
        timestamp: Date.now(),
        step: 'confirm'
      });

      // Limpar escolhas antigas (mais de 5 minutos)
      setTimeout(() => {
        pendingGroupChoices.delete(userJid);
      }, 5 * 60 * 1000);
      
      return;
    }

    // Se encontrou m√∫ltiplos grupos v√°lidos, perguntar qual
    const options = validGames.map(game => ({
      groupId: game.game.groupId,
      groupName: game.groupName,
      isCreatorGroup: true
    }));

    const choiceMessage = `Opa, que pessoa popular! üî• Vi que voc√™ t√° em mais de um grupo onde a brincadeira t√° rolando E o admin que criou tamb√©m t√° l√°! Para qual grupo voc√™ quer enviar essa foto? Responda com o n√∫mero:\n\n` +
                         options.map((option, index) => `${index + 1}. ${option.groupName}`).join('\n') +
                         `\n\n_Responda apenas com o n√∫mero (ex: 1, 2, 3...)_`;

    await sock.sendMessage(userJid, { 
      text: choiceMessage
    });

    // Salvar estado tempor√°rio
    pendingGroupChoices.set(userJid, {
      options,
      photoData: {
        messageId: message.key.id!,
        photoUrl: photoPath,
        caption
      },
      timestamp: Date.now(),
      step: 'choose'
    });

    // Limpar escolhas antigas (mais de 5 minutos)
    setTimeout(() => {
      pendingGroupChoices.delete(userJid);
    }, 5 * 60 * 1000);

  } catch (error) {
    console.error('[ERROR] Erro ao processar foto privada:', error);
    await sock.sendMessage(userJid, { 
      text: 'Eita, baby! ü´£ Deu erro ao processar sua foto! Tenta de novo! üíã' 
    });
  }
}

export async function handleGroupChoice(
  sock: WASocket,
  message: WAMessage,
  userJid: string,
  choice: string,
  gameService: GameService
): Promise<void> {
  try {
    const pendingChoice = pendingGroupChoices.get(userJid);
    if (!pendingChoice) {
      await sock.sendMessage(userJid, { 
        text: 'Eita, baby! ü´£ N√£o encontrei sua escolha pendente! Envie a foto novamente! üíã' 
      });
      return;
    }

    // Se est√° no passo de confirma√ß√£o
    if (pendingChoice.step === 'confirm') {
      const response = choice.toLowerCase().trim();
      
      if (response === 'sim' || response === '1' || response === 's' || response === 'y') {
        // Usu√°rio confirmou - salvar no grupo
        const selectedGroup = pendingChoice.options[0];
        
        // Verificar se j√° enviou
        const hasSubmitted = await gameService.hasUserSubmitted(selectedGroup.groupId, userJid);
        if (hasSubmitted) {
          await sock.sendMessage(userJid, { 
            text: 'Eita, baby! ü´£ Voc√™ j√° enviou uma foto para este jogo! S√≥ uma por pessoa, t√°? üíã' 
          });
          pendingGroupChoices.delete(userJid);
          return;
        }

        await gameService.addSubmission(selectedGroup.groupId, {
          senderJid: userJid,
          messageId: pendingChoice.photoData.messageId,
          photoUrl: pendingChoice.photoData.photoUrl,
          caption: pendingChoice.photoData.caption
        });

        await sock.sendMessage(userJid, { 
          text: `Perfeito! üòâ Foto enviada para o grupo "${selectedGroup.groupName}". Aguenta o cora√ß√£o a√≠! üíã` 
        });

        pendingGroupChoices.delete(userJid);
        return;
        
      } else if (response === 'n√£o' || response === 'nao' || response === '2' || response === 'n' || response === 'no') {
        // Usu√°rio n√£o confirmou - mostrar todas as op√ß√µes dispon√≠veis
        const allActiveGames = await gameService.findActiveGamesForUser(userJid);

        if (allActiveGames.length === 0) {
          await sock.sendMessage(userJid, { 
            text: 'Eita, baby! ü´£ N√£o encontrei outros grupos dispon√≠veis! üíã' 
          });
          pendingGroupChoices.delete(userJid);
          return;
        }

        const options = allActiveGames.map(game => ({
          groupId: game.groupId,
          groupName: game.groupName || 'Grupo Desconhecido',
          isCreatorGroup: false
        }));

        const choiceMessage = `Ok, baby! üòâ Aqui est√£o TODOS os grupos com brincadeira ativa:\n\n` +
                             options.map((option, index) => `${index + 1}. ${option.groupName}`).join('\n') +
                             `\n\n_Responda apenas com o n√∫mero (ex: 1, 2, 3...)_`;

        await sock.sendMessage(userJid, { 
          text: choiceMessage
        });

        // Atualizar estado para escolha
        pendingGroupChoices.set(userJid, {
          options,
          photoData: pendingChoice.photoData,
          timestamp: Date.now(),
          step: 'choose'
        });
        
        return;
      } else {
        await sock.sendMessage(userJid, { 
          text: `Eita, baby! ü´£ Resposta inv√°lida! Responda:\n‚úÖ Sim / 1 - Para confirmar\n‚ùå N√£o / 2 - Para ver outras op√ß√µes` 
        });
        return;
      }
    }

    // Se est√° no passo de escolha
    if (pendingChoice.step === 'choose') {
      const choiceNumber = parseInt(choice) - 1;
      if (choiceNumber < 0 || choiceNumber >= pendingChoice.options.length) {
        await sock.sendMessage(userJid, { 
          text: `Eita, baby! ü´£ Escolha inv√°lida! Digite um n√∫mero entre 1 e ${pendingChoice.options.length}! üíã` 
        });
        return;
      }

      const selectedGroup = pendingChoice.options[choiceNumber];
      
      // Verificar se j√° enviou
      const hasSubmitted = await gameService.hasUserSubmitted(selectedGroup.groupId, userJid);
      if (hasSubmitted) {
        await sock.sendMessage(userJid, { 
          text: 'Eita, baby! ü´£ Voc√™ j√° enviou uma foto para este jogo! S√≥ uma por pessoa, t√°? üíã' 
        });
        pendingGroupChoices.delete(userJid);
        return;
      }

      await gameService.addSubmission(selectedGroup.groupId, {
        senderJid: userJid,
        messageId: pendingChoice.photoData.messageId,
        photoUrl: pendingChoice.photoData.photoUrl,
        caption: pendingChoice.photoData.caption
      });

      await sock.sendMessage(userJid, { 
        text: `Perfeito! üòâ Foto enviada para o grupo "${selectedGroup.groupName}". Aguenta o cora√ß√£o a√≠! üíã` 
      });

      pendingGroupChoices.delete(userJid);
    }

  } catch (error) {
    console.error('[ERROR] Erro ao processar escolha de grupo:', error);
    await sock.sendMessage(userJid, { 
      text: 'Eita, baby! ü´£ Deu erro ao processar sua escolha! Tenta de novo! üíã' 
    });
  }
}

export function hasPendingChoice(userJid: string): boolean {
  return pendingGroupChoices.has(userJid);
}

// Exportar fun√ß√µes para uso no MessageManager - Confiss√µes
export async function handlePrivateConfessionSubmission(
  sock: WASocket, 
  message: WAMessage, 
  userJid: string,
  gameService: GameService
): Promise<void> {
  try {
    // FIX: Melhorar filtro para ignorar status, broadcast, lid e newsletter
    if (
      userJid.endsWith('@status') ||
      userJid.endsWith('@broadcast') ||
      userJid.endsWith('@lid') ||
      userJid.endsWith('@newsletter') ||
      userJid.endsWith('@g.us')
    ) {
      console.log('[DEBUG] Ignorando mensagem de status/broadcast/lid/newsletter/grupo:', userJid);
      return;
    }

    // FIX: Verificar se a mensagem √© do pr√≥prio bot
    if (message.key.fromMe) {
      console.log('[DEBUG] Ignorando mensagem do pr√≥prio bot');
      return;
    }

    // FIX: Verificar se √© realmente uma mensagem de texto
    if (!message.message?.conversation && !message.message?.extendedTextMessage?.text) {
      await sock.sendMessage(userJid, { 
        text: 'Eita, baby! ü´£ Para o confession√°rio, s√≥ aceito texto! Envie sua confiss√£o em formato de texto! üíã' 
      });
      return;
    }

    const confession = message.message?.conversation || message.message?.extendedTextMessage?.text || '';
    
    if (confession.trim().length < 10) {
      await sock.sendMessage(userJid, { 
        text: 'Eita, baby! ü´£ Sua confiss√£o t√° muito curta! Escreva mais um pouquinho, pelo menos 10 caracteres! üíã' 
      });
      return;
    }

    // Validar se a confiss√£o come√ßa com as frases permitidas
    if (!ConfessionGame.validateConfessionText(confession)) {
      await sock.sendMessage(userJid, { 
        text: 'Eita, baby! ü´£ Sua confiss√£o precisa come√ßar com "Eu nunca", "Eu j√°" ou "Uma vez"! Exemplos:\n\n' +
              '‚Ä¢ "Eu nunca colei em uma prova."\n' +
              '‚Ä¢ "Eu j√° comi pizza com ketchup."\n' +
              '‚Ä¢ "Uma vez, chamei a sogra pelo nome da ex."\n\n' +
              'Tenta de novo! üíã' 
      });
      return;
    }

    console.log(`[DEBUG] Processando confiss√£o privada de ${userJid}`);

    // Buscar jogos de confiss√£o ativos para o usu√°rio
    const activeConfessionGames = await gameService.findActiveConfessionGamesForUser(userJid);
    
    if (activeConfessionGames.length === 0) {
      await sock.sendMessage(userJid, { 
        text: 'Uhm, gato(a), recebi sua confiss√£o, mas n√£o encontrei nenhum grupo seu onde o "Confession√°rio" esteja rolando. Tem certeza que seu admin j√° ativou a brincadeira com !brincadeira confissao ativar? ü§î' 
      });
      return;
    }

    // Buscar grupos onde o usu√°rio √© membro
    const userGroups = await Group.find({ members: userJid });
    const userGroupIds = userGroups.map(g => g.groupJid);

    // Filtrar jogos ativos onde o usu√°rio √© membro
    const userActiveConfessionGames = activeConfessionGames.filter(game => userGroupIds.includes(game.groupId));

    if (userActiveConfessionGames.length === 0) {
      await sock.sendMessage(userJid, { 
        text: 'Eita, baby! ü´£ Encontrei confession√°rios ativos, mas voc√™ n√£o √© membro de nenhum deles! Que estranho... üíã' 
      });
      return;
    }

    // Para cada jogo ativo, verificar se o criador tamb√©m √© membro
    const validConfessionGames: Array<{ game: any; groupName: string; isCreatorGroup: boolean }> = [];
    
    for (const game of userActiveConfessionGames) {
      try {
        const groupDoc = await Group.findOne({ groupJid: game.groupId });
        if (groupDoc && groupDoc.members.includes(game.createdBy)) {
          // Ambos s√£o membros do grupo
          validConfessionGames.push({
            game,
            groupName: game.groupName || groupDoc.name || 'Grupo Desconhecido',
            isCreatorGroup: true
          });
        }
      } catch (error) {
        console.error(`[ERROR] Erro ao verificar grupo ${game.groupId}:`, error);
      }
    }

    // Se n√£o encontrou grupos onde ambos s√£o membros, mostrar todos os grupos dispon√≠veis
    if (validConfessionGames.length === 0) {
      // Mostrar TODOS os jogos ativos dispon√≠veis, n√£o apenas os do usu√°rio
      const allAvailableConfessionGames = activeConfessionGames.map(game => ({
        game,
        groupName: game.groupName || 'Grupo Desconhecido',
        isCreatorGroup: false
      }));

      const options = allAvailableConfessionGames.map((game, index) => ({
        groupId: game.game.groupId,
        groupName: game.groupName,
        isCreatorGroup: false
      }));

      const choiceMessage = `Opa, que pessoa popular! üî• Vi que voc√™ t√° em grupos onde o confession√°rio t√° rolando, mas n√£o encontrei o admin que criou o jogo. Aqui est√£o TODOS os grupos com confession√°rio ativo. Para qual grupo voc√™ quer enviar sua confiss√£o? Responda com o n√∫mero:\n\n` +
                           options.map((option, index) => `${index + 1}. ${option.groupName}`).join('\n') +
                           `\n\n_Responda apenas com o n√∫mero (ex: 1, 2, 3...)_`;

      await sock.sendMessage(userJid, { 
        text: choiceMessage
      });

      // Salvar estado tempor√°rio
      pendingConfessionChoices.set(userJid, {
        options,
        confessionData: {
          messageId: message.key.id!,
          confession
        },
        timestamp: Date.now(),
        step: 'choose'
      });

      // Limpar escolhas antigas (mais de 5 minutos)
      setTimeout(() => {
        pendingConfessionChoices.delete(userJid);
      }, 5 * 60 * 1000);
      
      return;
    }

    // Se encontrou apenas um grupo v√°lido, confirmar
    if (validConfessionGames.length === 1) {
      const game = validConfessionGames[0];
      
      // Verificar se j√° enviou
      const hasSubmitted = await gameService.hasUserSubmittedConfession(game.game.groupId, userJid);
      if (hasSubmitted) {
        await sock.sendMessage(userJid, { 
          text: 'Eita, baby! ü´£ Voc√™ j√° enviou uma confiss√£o para este confession√°rio! S√≥ uma por pessoa, t√°? üíã' 
        });
        return;
      }

      const confirmMessage = `Ui, que confiss√£o! üòâ Encontrei o confession√°rio no grupo "${game.groupName}". Quer enviar sua confiss√£o para esse grupo?\n\n` +
                            `Responda:\n` +
                            `‚úÖ Sim / 1 - Para confirmar\n` +
                            `‚ùå N√£o / 2 - Para ver outras op√ß√µes`;

      await sock.sendMessage(userJid, { 
        text: confirmMessage
      });

      // Salvar estado tempor√°rio para confirma√ß√£o
      pendingConfessionChoices.set(userJid, {
        options: [{
          groupId: game.game.groupId,
          groupName: game.groupName,
          isCreatorGroup: true
        }],
        confessionData: {
          messageId: message.key.id!,
          confession
        },
        timestamp: Date.now(),
        step: 'confirm'
      });

      // Limpar escolhas antigas (mais de 5 minutos)
      setTimeout(() => {
        pendingConfessionChoices.delete(userJid);
      }, 5 * 60 * 1000);
      
      return;
    }

    // Se encontrou m√∫ltiplos grupos v√°lidos, perguntar qual
    const options = validConfessionGames.map(game => ({
      groupId: game.game.groupId,
      groupName: game.groupName,
      isCreatorGroup: true
    }));

    const choiceMessage = `Opa, que pessoa popular! üî• Vi que voc√™ t√° em mais de um grupo onde o confession√°rio t√° rolando E o admin que criou tamb√©m t√° l√°! Para qual grupo voc√™ quer enviar sua confiss√£o? Responda com o n√∫mero:\n\n` +
                         options.map((option, index) => `${index + 1}. ${option.groupName}`).join('\n') +
                         `\n\n_Responda apenas com o n√∫mero (ex: 1, 2, 3...)_`;

    await sock.sendMessage(userJid, { 
      text: choiceMessage
    });

    // Salvar estado tempor√°rio
    pendingConfessionChoices.set(userJid, {
      options,
      confessionData: {
        messageId: message.key.id!,
        confession
      },
      timestamp: Date.now(),
      step: 'choose'
    });

    // Limpar escolhas antigas (mais de 5 minutos)
    setTimeout(() => {
      pendingConfessionChoices.delete(userJid);
    }, 5 * 60 * 1000);

  } catch (error) {
    console.error('[ERROR] Erro ao processar confiss√£o privada:', error);
    await sock.sendMessage(userJid, { 
      text: 'Eita, baby! ü´£ Deu erro ao processar sua confiss√£o! Tenta de novo! üíã' 
    });
  }
}

export async function handleConfessionGroupChoice(
  sock: WASocket,
  message: WAMessage,
  userJid: string,
  choice: string,
  gameService: GameService
): Promise<void> {
  try {
    const pendingChoice = pendingConfessionChoices.get(userJid);
    if (!pendingChoice) {
      await sock.sendMessage(userJid, { 
        text: 'Eita, baby! ü´£ N√£o encontrei sua escolha pendente! Envie a confiss√£o novamente! üíã' 
      });
      return;
    }

    // Se est√° no passo de confirma√ß√£o
    if (pendingChoice.step === 'confirm') {
      const response = choice.toLowerCase().trim();
      
      if (response === 'sim' || response === '1' || response === 's' || response === 'y') {
        // Usu√°rio confirmou - salvar no grupo
        const selectedGroup = pendingChoice.options[0];
        
        // Verificar se j√° enviou
        const hasSubmitted = await gameService.hasUserSubmittedConfession(selectedGroup.groupId, userJid);
        if (hasSubmitted) {
          await sock.sendMessage(userJid, { 
            text: 'Eita, baby! ü´£ Voc√™ j√° enviou uma confiss√£o para este confession√°rio! S√≥ uma por pessoa, t√°? üíã' 
          });
          pendingConfessionChoices.delete(userJid);
          return;
        }

        await gameService.addConfession(selectedGroup.groupId, {
          senderJid: userJid,
          messageId: pendingChoice.confessionData.messageId,
          confession: pendingChoice.confessionData.confession
        });

        await sock.sendMessage(userJid, { 
          text: `Perfeito! üòâ Confiss√£o enviada para o grupo "${selectedGroup.groupName}". Aguenta o cora√ß√£o a√≠! üíã` 
        });

        pendingConfessionChoices.delete(userJid);
        return;
        
      } else if (response === 'n√£o' || response === 'nao' || response === '2' || response === 'n' || response === 'no') {
        // Usu√°rio n√£o confirmou - mostrar todas as op√ß√µes dispon√≠veis
        const allActiveConfessionGames = await gameService.findActiveConfessionGamesForUser(userJid);

        if (allActiveConfessionGames.length === 0) {
          await sock.sendMessage(userJid, { 
            text: 'Eita, baby! ü´£ N√£o encontrei outros grupos dispon√≠veis! üíã' 
          });
          pendingConfessionChoices.delete(userJid);
          return;
        }

        const options = allActiveConfessionGames.map(game => ({
          groupId: game.groupId,
          groupName: game.groupName || 'Grupo Desconhecido',
          isCreatorGroup: false
        }));

        const choiceMessage = `Ok, baby! üòâ Aqui est√£o TODOS os grupos com confession√°rio ativo:\n\n` +
                             options.map((option, index) => `${index + 1}. ${option.groupName}`).join('\n') +
                             `\n\n_Responda apenas com o n√∫mero (ex: 1, 2, 3...)_`;

        await sock.sendMessage(userJid, { 
          text: choiceMessage
        });

        // Atualizar estado para escolha
        pendingConfessionChoices.set(userJid, {
          options,
          confessionData: pendingChoice.confessionData,
          timestamp: Date.now(),
          step: 'choose'
        });
        
        return;
      } else {
        await sock.sendMessage(userJid, { 
          text: `Eita, baby! ü´£ Resposta inv√°lida! Responda:\n‚úÖ Sim / 1 - Para confirmar\n‚ùå N√£o / 2 - Para ver outras op√ß√µes` 
        });
        return;
      }
    }

    // Se est√° no passo de escolha
    if (pendingChoice.step === 'choose') {
      const choiceNumber = parseInt(choice) - 1;
      if (choiceNumber < 0 || choiceNumber >= pendingChoice.options.length) {
        await sock.sendMessage(userJid, { 
          text: `Eita, baby! ü´£ Escolha inv√°lida! Digite um n√∫mero entre 1 e ${pendingChoice.options.length}! üíã` 
        });
        return;
      }

      const selectedGroup = pendingChoice.options[choiceNumber];
      
      // Verificar se j√° enviou
      const hasSubmitted = await gameService.hasUserSubmittedConfession(selectedGroup.groupId, userJid);
      if (hasSubmitted) {
        await sock.sendMessage(userJid, { 
          text: 'Eita, baby! ü´£ Voc√™ j√° enviou uma confiss√£o para este confession√°rio! S√≥ uma por pessoa, t√°? üíã' 
        });
        pendingConfessionChoices.delete(userJid);
        return;
      }

      await gameService.addConfession(selectedGroup.groupId, {
        senderJid: userJid,
        messageId: pendingChoice.confessionData.messageId,
        confession: pendingChoice.confessionData.confession
      });

      await sock.sendMessage(userJid, { 
        text: `Perfeito! üòâ Confiss√£o enviada para o grupo "${selectedGroup.groupName}". Aguenta o cora√ß√£o a√≠! üíã` 
      });

      pendingConfessionChoices.delete(userJid);
    }

  } catch (error) {
    console.error('[ERROR] Erro ao processar escolha de grupo de confiss√£o:', error);
    await sock.sendMessage(userJid, { 
      text: 'Eita, baby! ü´£ Deu erro ao processar sua escolha! Tenta de novo! üíã' 
    });
  }
}

export function hasPendingConfessionChoice(userJid: string): boolean {
  return pendingConfessionChoices.has(userJid);
}

const brincadeiraCommand = new BrincadeiraCommand(new GameService());
export default brincadeiraCommand; 
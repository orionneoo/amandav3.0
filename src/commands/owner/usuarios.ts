import { WASocket, proto } from '@whiskeysockets/baileys';
import { IInjectableCommand } from '@/interfaces/ICommand';
import { injectable, inject } from 'inversify';
import { OwnerService } from '@/services/OwnerService';
import { GroupActivity } from '@/database/models/GroupActivitySchema';
import { TYPES } from '@/config/container';
import { DatabaseService } from '@/services/DatabaseService';
import { DatabaseStatus } from '@/utils/databaseStatus';
import { MessageContext } from '@/handlers/message.handler';

type WAMessage = proto.IWebMessageInfo;

@injectable()
export class UsuariosCommand implements IInjectableCommand {
  public name = 'usuarios';
  public description = 'Gerencia usu√°rios do bot';
  public category = 'admin' as const;
  public usage = '!usuarios [comando] [op√ß√µes]';
  public aliases = ['users', 'membros'];

  private readonly OWNER_NUMBER = '5521967233931';

  constructor(
    @inject(TYPES.OwnerService) private ownerService: OwnerService
  ) {}

  public async handle(context: MessageContext): Promise<void> {
    const { sock, messageInfo: message, args } = context;
    const userJid = message.key.participant || message.key.remoteJid!;
    const isPrivate = !message.key.remoteJid!.endsWith('@g.us');
    
    // Verificar se √© o dono
    const userNumber = userJid.split('@')[0];
    if (userNumber !== this.OWNER_NUMBER) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: 'üö´ *Acesso Negado*\n\nEste comando √© exclusivo do dono do bot!'
      });
      return;
    }

    // Verificar se √© conversa privada
    if (!isPrivate) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: 'üîí *Comando Privado*\n\nEste comando s√≥ pode ser usado em conversa privada com o bot!'
      });
      return;
    }

    // Verificar autentica√ß√£o
    const isAuthenticated = await this.ownerService.isAuthenticated(userJid);
    if (!isAuthenticated) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: 'üîê *Autentica√ß√£o Necess√°ria*\n\nUse `!dono senha [senha]` para se autenticar primeiro.'
      });
      return;
    }

    const command = args[0]?.toLowerCase();

    switch (command) {
      case 'listar':
        await this.listUsers(sock, message, args.slice(1));
        break;
      case 'buscar':
        await this.searchUser(sock, message, args.slice(1));
        break;
      case 'banir':
        await this.banUser(sock, message, args.slice(1));
        break;
      case 'desbanir':
        await this.unbanUser(sock, message, args.slice(1));
        break;
      case 'estatisticas':
        await this.userStats(sock, message, args.slice(1));
        break;
      case 'ajuda':
      case 'help':
        await this.showHelp(sock, message);
        break;
      default:
        await this.showHelp(sock, message);
        break;
    }
  }

  private async listUsers(sock: WASocket, message: WAMessage, args: string[]): Promise<void> {
    try {
      // Verificar se o banco est√° offline
      if (DatabaseStatus.getInstance().isDatabaseOffline()) {
        await sock.sendMessage(message.key.remoteJid!, {
          text: DatabaseStatus.getInstance().getOfflineMessage('Lista de Usu√°rios')
        });
        return;
      }

      const limit = parseInt(args[0]) || 20;
      
      // NOVO: Implementar busca real de usu√°rios
      let users: any[] = [];
      try {
        const { UserSession } = await import('@/database/UserSessionSchema');
        users = await UserSession.find({})
          .sort({ lastInteraction: -1 })
          .limit(limit)
          .lean();
      } catch (error) {
        // Fallback: buscar baseado em atividades recentes
        const { GroupActivity } = await import('@/database/models/GroupActivitySchema');
        const recentUsers = await GroupActivity.aggregate([
          { $match: { timestamp: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) } } },
          { $group: { _id: '$userJid', lastActivity: { $max: '$timestamp' } } },
          { $sort: { lastActivity: -1 } },
          { $limit: limit }
        ]);
        
        users = recentUsers.map(user => ({
          jid: user._id,
          lastInteraction: user.lastActivity
        }));
      }

      let messageText = `üë• *LISTA DE USU√ÅRIOS* (${users.length})\n\n`;
      
      if (users.length === 0) {
        messageText += 'Nenhum usu√°rio encontrado.';
      } else {
        users.forEach((user, index) => {
          const number = user.jid?.split('@')[0] || 'N/A';
          const lastSeen = user.lastInteraction ? 
            new Date(user.lastInteraction).toLocaleDateString('pt-BR') : 'N/A';
          
          messageText += `${index + 1}. ${number}\n`;
          messageText += `   üìÖ √öltima atividade: ${lastSeen}\n\n`;
        });
      }

      await sock.sendMessage(message.key.remoteJid!, { text: messageText });
    } catch (error) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: '‚ùå Erro ao listar usu√°rios. Se o problema persistir, chama o meu criador: +55 21 6723-3931 - ele vai resolver! üîß'
      });
    }
  }

  private async searchUser(sock: WASocket, message: WAMessage, args: string[]): Promise<void> {
    if (args.length === 0) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: '‚ùå *N√∫mero Obrigat√≥rio*\n\nUse: `!usuarios buscar [numero]`'
      });
      return;
    }

    try {
      // Verificar se o banco est√° offline
      if (DatabaseStatus.getInstance().isDatabaseOffline()) {
        await sock.sendMessage(message.key.remoteJid!, {
          text: DatabaseStatus.getInstance().getOfflineMessage('Busca de Usu√°rio')
        });
        return;
      }

      const searchNumber = args[0].replace(/\D/g, '');
      
      // NOVO: Implementar busca real de usu√°rio
      let user: any = null;
      try {
        const { UserSession } = await import('@/database/UserSessionSchema');
        user = await UserSession.findOne({ jid: new RegExp(searchNumber) }).lean();
      } catch (error) {
        // Fallback: buscar em atividades
        const { GroupActivity } = await import('@/database/models/GroupActivitySchema');
        const activities = await GroupActivity.find({ 
          userJid: new RegExp(searchNumber) 
        }).sort({ timestamp: -1 }).limit(10).lean();
        
        if (activities.length > 0) {
          user = {
            jid: activities[0].userJid,
            lastInteraction: activities[0].timestamp,
            activities: activities.length
          };
        }
      }

      if (!user) {
        await sock.sendMessage(message.key.remoteJid!, {
          text: `‚ùå *Usu√°rio n√£o encontrado*\n\nNenhum usu√°rio encontrado com o n√∫mero ${searchNumber}`
        });
        return;
      }

      // Verificar se est√° banido
      const { Blacklist } = await import('@/database/models/BlacklistSchema');
      const banInfo = await Blacklist.findOne({ 
        userJid: user.jid,
        active: true
      }).lean();

      let userInfo = `üë§ *INFORMA√á√ïES DO USU√ÅRIO*\n\n`;
      userInfo += `üì± *N√∫mero:* ${user.jid?.split('@')[0] || searchNumber}\n`;
      userInfo += `üìÖ *√öltima atividade:* ${user.lastInteraction ? 
        new Date(user.lastInteraction).toLocaleString('pt-BR') : 'N/A'}\n`;
      
      if (user.activities) {
        userInfo += `üìä *Atividades recentes:* ${user.activities}\n`;
      }

      if (banInfo) {
        userInfo += `\nüö´ *STATUS:* BANIDO\n`;
        userInfo += `üìù *Motivo:* ${banInfo.reason}\n`;
        userInfo += `üìÖ *Banido em:* ${new Date(banInfo.bannedAt).toLocaleDateString('pt-BR')}\n`;
      } else {
        userInfo += `\n‚úÖ *STATUS:* Ativo`;
      }

      await sock.sendMessage(message.key.remoteJid!, { text: userInfo });
    } catch (error) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: '‚ùå Erro ao buscar usu√°rio. Se o problema persistir, chama o meu criador: +55 21 6723-3931 - ele vai resolver! üîß'
      });
    }
  }

  private async banUser(sock: WASocket, message: WAMessage, args: string[]): Promise<void> {
    if (args.length === 0) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: '‚ùå *N√∫mero Obrigat√≥rio*\n\nUse: `!usuarios banir [numero] [motivo]`'
      });
      return;
    }

    try {
      // Verificar se o banco est√° offline
      if (DatabaseStatus.getInstance().isDatabaseOffline()) {
        await sock.sendMessage(message.key.remoteJid!, {
          text: DatabaseStatus.getInstance().getOfflineMessage('Banir Usu√°rio')
        });
        return;
      }

      const number = args[0].replace(/\D/g, '');
      const motivo = args.slice(1).join(' ') || 'Banido pelo dono';
      
      // NOVO: Implementar sistema de ban real
      const { Blacklist } = await import('@/database/models/BlacklistSchema');
      
      // Verificar se j√° est√° banido
      const existingBan = await Blacklist.findOne({ 
        number: number,
        active: true 
      });
      
      if (existingBan) {
        await sock.sendMessage(message.key.remoteJid!, {
          text: `‚ö†Ô∏è *Usu√°rio J√° Banido*\n\nO n√∫mero ${number} j√° est√° na blacklist.\nMotivo: ${existingBan.reason}`
        });
        return;
      }
      
      // Adicionar √† blacklist
      const newBan = new Blacklist({
        number: number,
        userJid: `${number}@s.whatsapp.net`,
        reason: motivo,
        bannedBy: this.OWNER_NUMBER + '@s.whatsapp.net'
      });
      await newBan.save();

      await sock.sendMessage(message.key.remoteJid!, {
        text: `‚úÖ *Usu√°rio Banido*\n\nO n√∫mero ${number} foi adicionado √† blacklist.`
      });
      
    } catch (error) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: '‚ùå Erro ao banir usu√°rio. Se o problema persistir, chama o meu criador: +55 21 6723-3931 - ele vai resolver! üîß'
      });
    }
  }

  private async unbanUser(sock: WASocket, message: WAMessage, args: string[]): Promise<void> {
    if (args.length === 0) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: '‚ùå *N√∫mero Obrigat√≥rio*\n\nUse: `!usuarios desbanir [numero]`'
      });
      return;
    }

    try {
      // Verificar se o banco est√° offline
      if (DatabaseStatus.getInstance().isDatabaseOffline()) {
        await sock.sendMessage(message.key.remoteJid!, {
          text: DatabaseStatus.getInstance().getOfflineMessage('Desbanir Usu√°rio')
        });
        return;
      }

      const number = args[0].replace(/\D/g, '');
      
      // NOVO: Implementar sistema de desbanir real
      const { Blacklist } = await import('@/database/models/BlacklistSchema');
      
      // Verificar se est√° banido
      const banInfo = await Blacklist.findOne({ 
        number: number,
        active: true 
      });

      if (!banInfo) {
        await sock.sendMessage(message.key.remoteJid!, {
          text: `‚úÖ *Usu√°rio N√£o Banido*\n\nO n√∫mero ${number} n√£o est√° na blacklist.`
        });
        return;
      }

      // Desativar ban
      banInfo.active = false;
      await banInfo.save();

      await sock.sendMessage(message.key.remoteJid!, {
        text: `‚úÖ *Usu√°rio Desbanido*\n\nO n√∫mero ${number} foi removido da blacklist.`
      });
      
    } catch (error) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: '‚ùå Erro ao desbanir usu√°rio. Se o problema persistir, chama o meu criador: +55 21 6723-3931 - ele vai resolver! üîß'
      });
    }
  }

  private async userStats(sock: WASocket, message: WAMessage, args: string[]): Promise<void> {
    try {
      // Verificar se o banco est√° offline
      if (DatabaseStatus.getInstance().isDatabaseOffline()) {
        await sock.sendMessage(message.key.remoteJid!, {
          text: DatabaseStatus.getInstance().getOfflineMessage('Estat√≠sticas de Usu√°rios')
        });
        return;
      }

      // NOVO: Implementar estat√≠sticas reais
      let totalUsers = 0;
      let activeLast7Days = 0;
      let bannedUsers = 0;
      let topGroups: any[] = [];
      
      try {
        const { UserSession } = await import('@/database/UserSessionSchema');
        const { Blacklist } = await import('@/database/models/BlacklistSchema');
        const { GroupActivity } = await import('@/database/models/GroupActivitySchema');
        
        totalUsers = await UserSession.countDocuments();
        
        const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        activeLast7Days = await UserSession.countDocuments({ 
          lastInteraction: { $gte: sevenDaysAgo } 
        });
        
        bannedUsers = await Blacklist.countDocuments({ active: true });
        
        topGroups = await GroupActivity.aggregate([
          { $group: { _id: '$groupJid', messages: { $sum: 1 } } },
          { $sort: { messages: -1 } },
          { $limit: 3 }
        ]);
        
      } catch (error) {
        // Fallback se schemas n√£o existirem
      }

      let statsText = `üìä *ESTAT√çSTICAS DE USU√ÅRIOS*\n\n`;
      statsText += `üë• Total de usu√°rios: ${totalUsers}\n`;
      statsText += `‚úÖ Ativos (7 dias): ${activeLast7Days}\n`;
      statsText += `üö´ Banidos: ${bannedUsers}\n\n`;
      
      statsText += `üèÜ *TOP 3 GRUPOS MAIS ATIVOS:*\n`;
      if (topGroups.length > 0) {
        for (let i = 0; i < topGroups.length; i++) {
          const group = topGroups[i];
          const groupName = await this.getGroupName(group._id);
          statsText += `${i + 1}. ${groupName} (${group.messages} msgs)\n`;
        }
      } else {
        statsText += 'Nenhum grupo ativo encontrado.';
      }

      await sock.sendMessage(message.key.remoteJid!, { text: statsText });
      
    } catch (error) {
      await sock.sendMessage(message.key.remoteJid!, {
        text: '‚ùå Erro ao gerar estat√≠sticas de usu√°rios. Se o problema persistir, chama o meu criador: +55 21 6723-3931 - ele vai resolver! üîß'
      });
    }
  }

  private async showHelp(sock: WASocket, message: WAMessage): Promise<void> {
    const helpText = `üë• *COMANDO DE USU√ÅRIOS*\n\n` +
                    `*Uso:* \`!usuarios [comando]\`\n\n` +
                    `*Comandos dispon√≠veis:*\n` +
                    `üìã \`listar [limite]\` - Lista usu√°rios (padr√£o: 20)\n` +
                    `üîç \`buscar [numero]\` - Busca um usu√°rio\n` +
                    `üö´ \`banir [numero] [motivo]\` - Bane um usu√°rio\n` +
                    `‚úÖ \`desbanir [numero]\` - Desbane um usu√°rio\n` +
                    `üìä \`estatisticas\` - Mostra estat√≠sticas\n` +
                    `‚ùì \`ajuda\` - Mostra esta mensagem\n\n` +
                    `*Exemplos:*\n` +
                    `‚Ä¢ \`!usuarios listar 50\`\n` +
                    `‚Ä¢ \`!usuarios buscar 5521... \`\n` +
                    `‚Ä¢ \`!usuarios banir 5521... spammer\``;

    await sock.sendMessage(message.key.remoteJid!, { text: helpText });
  }

  private async getGroupName(groupJid: string): Promise<string> {
    try {
      const { Group } = await import('@/database/models/GroupSchema');
      const group = await Group.findOne({ groupJid }).lean();
      return group?.name || groupJid;
    } catch (error) {
      return groupJid;
    }
  }

  private getDateRange(period: string): { startDate: Date; endDate: Date } {
    const endDate = new Date();
    let startDate: Date;

    switch (period) {
      case 'hoje':
        startDate = new Date();
        startDate.setHours(0, 0, 0, 0);
        break;
      case 'semana':
        startDate = new Date();
        startDate.setDate(startDate.getDate() - 7);
        break;
      case 'mes':
        startDate = new Date();
        startDate.setMonth(startDate.getMonth() - 1);
        break;
      case 'ano':
        startDate = new Date();
        startDate.setFullYear(startDate.getFullYear() - 1);
        break;
      default: // Padr√£o para semana
        startDate = new Date();
        startDate.setDate(startDate.getDate() - 7);
        break;
    }
    return { startDate, endDate };
  }
}

export default UsuariosCommand; 